# 1. 代码生成器的主要任务
- 指令选择：选择适当的**目标机指令**来实现**中间表示（IR）语句**
例：三地址语句：```x = y + z```，目标代码如下：
```
LD R0, y       // 把y的值加载到寄存器R0中
ADD R0, R0, z  // z加到R0上
ST x, R0       // 把R0的值保存到x中
```
- 寄存器分配和指派：把哪个值放在哪个寄存器中
- 指令排序，按照什么顺序来排列指令顺序，使目标程序执行效率更高
# 2. 指令选择
- 三地址语句```x=y-z```
- 目标代码  
```
LD R1, y       // R1 = y
LD R2, z       // R2 = z
SUB R1, R1, R2 // R1 = R1 - R2
ST x, R1       // x = R1
```
优秀的目标代码应尽可能避免使用上面的全部四个指令，如果：
- 所需的运算分类已经在寄存器中了
- 运算结果不需要存放回寄存器
# 3. 寄存器的选择

- 对每个形如```x=y op z```的三地址指令**I**，执行如下动作：
    - 调用函数```getreg(I)```来为x、y、z选择寄存器，把这些寄存器称为Rx，Ry，Rz
    - 如果Ry中存放的不是y，则生成指令```LD Ry, y'```，y'是存放y的内存位置之一
    - 类似的，如果Rz中存放的不是z，生成指令```LD Rz, z'```
    - 生成目标指令``` OP Rx, Ry, Rz```


在代码生成过程中，我们需要一些数据结构来说明：
- **哪些变量的值当前存放在哪些寄存器中**
- **还需要知道一个变量的内存地址中存放的值，是否是该变量的正确值**，因为该变量的最新值可能刚在寄存器中计算出来，还未保存回内存地址中
## 3.1. 寄存器描述符和地址描述符
- 寄存器描述符：记录每个**寄存器**当前存放的是哪些变量的值
- 地址描述符：记录运行时每个**名字**的当前值存放在哪个位置或哪些位置。该位置科恩那个是寄存器、栈单元、内存地址或者是它们的某个集合。这些信息可以存放在该变量名对应的符号表条目中
### 3.1.1. 基本块的收尾处理
对于一个在基本块的出口处可能**活跃**的变量x，如果它的地址描述符表明它的值没有存放在x的内存位置上，则生成指令``` ST x, R``` （R是在基本块结尾处存放x值的寄存器）

### 3.1.2. 管理寄存器和地址描述符
当代码生成算法生成**加载**、**保存**和其他指令时，它必须同时更新寄存器和地址描述符
- 对于指令```LD R, x```
    - 修改R的寄存器描述符，使之只包含x
    - 修改x的地址描述符，把R作为新增位置加入到x的地址描述符中
    - 从任何不同于x的地址描述符中删除R
- 对于指令```OP Rx, Ry, Rz```
    - 修改Rx的寄存器描述符，使之只包含x
    - 从任何不同于Rx的寄存器描述符中删除x
    - 修改x的地址描述符，使之只包含位置Rx
    - 从任何不同于x的地址描述符中删除R
- 对于指令```ST x, R```
    - 修改x的地址描述符，使之包含自己的内存位置
- 对于复制语句```x=y```，如果需要生成加载指令```LD Ry, y'```，则
    - 修改Rx的寄存器描述符，使之只包含y
    - 修改y的地址描述符，把Ry作为新增位置加入到y的位置集合中
    - 从任何不同于y的变量的地址描述符中删除Ry
    - 修改Ry的寄存器描述符，使之也包含x
    - 修改x的地址描述符，使之只包含Ry

# 4. 窥孔优化
- 窥孔（peelhole）：是程序上的一个小的滑动窗口  
- 窥孔优化是指在优化的时候，检查目标指令的一个滑动窗口（即窥孔），并且只要有可能就在窥孔内用更快或更短的指令来替换窗口中的指令序列
- 也可以在**中间代码生成**以后，直接应用窥孔优化来提高中间表示形式的质量
## 具有窥孔优化特点的程序变换的例子
### 冗余指令的删除
- 消除冗余的加载和保存指令
```
LD R0, b          // R0 = b
ADD R0, R0, c     // R0 = R0 + c
ST a, R0          // a = R0
LD R0, a          // R0 = a
ADD R0, R0, e     // R0 = R0 + e
ST d, R0          // d = R0
```
上述目标代码中，第四条指令是冗余的，可删除。但如果第四条指令有标号，则不能删除。
- 消除不可达代码：一个紧跟在**无条件跳转**之后的**不带标号**的指令可以被删除
```
if debug == 1 goto L1
goto L2

L1: print debugging info
L2: 
```
上述代码可以优化为：
```
if debug != 1 goto L2
print debugging info
L2:
```
### 控制流优化
- 在代码中出现**跳转到跳转指令的指令**时，某些条件下可以使用**一个跳转指令**来代替
```
if a < b goto L1
...
L1: goto L2
```
优化为：
```
if a < b goto L2
```
### 代数优化
- 代数恒等式：消除窥孔中类似于```x=x+0```或```x=x*1```的运算指令
- 强度削弱
    - 对于乘数（除数）是2的幂次的定点数乘法（除法），用移位运算实现代价比较低
    - 除数为常量的浮点数除法，可以通过乘数为该常量倒数的乘法来求近似值

### 机器特有指令的使用
充分利用目标系统的某些高效指令来

