编译器必须准确地实现源程序语言中包含的各个抽象概念（名字、作用域、数据类型、运算符、过程等），还必须和操作系统以及其他软件协作，在目标机上支持这些概念。为此，编译器创建并管理一个**运行时刻环境**，编译得到的目标程序就运行在这个环境中。
# 1. 存储组织
编译器在工作过程中，必须为源程序中出现的一些数据对象分配运行时的存储空间。  
- 对于那些在**编译时刻**就可以确定大小的数据对象，可以在编译时刻就为它们分配存储空间，这样的分配策略称为**静态存储分配**
- 反之，如果不能在编译时完全确定数据对象的大小，就要采用**动态存储分配**的策略。即，在编译时仅产生各种必要的信息，而在**运行时刻**，再动态地分配数据对象的存储空间。

动态存储分配一般分为**栈式存储分配**和**堆式存储分配**。静态和动态分别对应于编译时刻和运行时刻。

![运行时内存的划分](./Picture/34.%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png)

- 编译产生的目标代码的大小，在编译时就可以确定，因此存放在静态代码区
- 程序的某些数据对象的大小可以在编译时刻知道，它们可以被放置在另一个称为静态数据区的区域中，该区域可以被静态确定，通常包含**全局常量**和**编译器产生的数据**
- 堆和栈是动态的，随着程序运行而动态变化。栈中存放**活动记录**。

## 活动记录
- 使用**过程**（或函数、方法）作为用户自定义动作的单元的语言，其编译器通常**以过程为单位分配存储空间**
- 过程体的每次执行称为该过程的一个**活动**（Activation）
- 过程每执行一次，就为它分配一块连续存储区，用来管理过程一次执行所需的信息，这块连续存储区域称为**活动记录**
## 活动记录的一般形式
![活动记录](./Picture/35.%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95.png)  

# 2. 静态存储分配
- 静态存储分配中，编译器为每个过程确定其活动记录在目标程序中的位置。这样，过程中每个名字的存储位置就确定了
- 因此，这些名字的存储地址可以被编译到目标代码中
- 过程每次执行时，它的名字都绑定到同样的存储单元
## 适合静态存储分配的限制条件
适合静态存储分配的语言必须满足以下条件：
- 数组上下界必须是常数，否则不能在编译时刻确定数组大小
- 不允许过程的递归调用，否则，同一时刻一个过程可能有若干个过程处于活跃状态，编译时刻无法确定一个过程处于多少个活跃状态。
- 不允许动态建立数据实体

满足这些条件的语言有BASIC和FORTRAN等
## 常用的静态存储分配方法
- 顺序分配法：
    - 按照过程出现的先后顺序逐段分配存储空间
    - 各过程的活动记录占用互不相交的存储空间
    - 处理简单，但对内存空间是使用不够经济合理  

![顺序分配法](./Picture/36.%E9%A1%BA%E5%BA%8F%E5%88%86%E9%85%8D%E6%B3%95.png)

- 层次分配法
    - 通过对过程间的调用关系进行分析，凡属无相互调用关系的并列过程，尽量使其局部数据共享存储空间

![层次分配法](./Picture/37.%E5%B1%82%E6%AC%A1%E5%88%86%E9%85%8D%E6%B3%95.png)

# 3. 栈式存储分配
- 有些语言使用过程、函数或方法作为用户自定义动作的单元，几乎所有针对这些语言的比那一起都把它们的（至少一部分的）运行时刻存储以**栈**的形式进行管理，称为**栈式存储分配**。
- 当一个过程被**调用**时，该过程的活动记录被**压入**栈；当过程**结束**时，该活动记录被**弹出**栈
- 这种安排不仅允许活跃时段不交叠的多个过程调用之间**共享空间**，而且允许以如下方式为一个过程编译代码：它的非局部变量的**相对地址总是固定的**，和过程调用序列无关
## 活动树
- 用来描述程序**运行**期间控制进入和离开各个活动的情况的树称为**活动树**
- 树中的每个结点对应于一个活动。根节点是启动程序执行的**main过程的活动**
- 在表示过程p的某个活动的结点上，其子结点对应于被p的这次活动调用的各个过程的活动。按照这些活动被调用的顺序，自左向右地显示它们。**一个子结点必须在其右兄弟结点的活动开始之前结束**。
```
int a[11];

void readArray() // 将9个整数读入a[1],...,a[9]中
{
    int i;
    ...
}

int partition(int m, int n) // 选择一个分割值v，划分a[m...n]，使得a[m...p-1]<v，a[p]=v，a[p+1...n]>v，返回p
{
    ...
}

void quicksort(int m, int n)
{
    int i;
    if (n > m) {
        i = partition(m, n);
        quicksort(m, i-1);
        quicksort(i+1, n);
    }
}

main()
{
    readArray();
    a[0] = -9999;
    a[10] = 9999;
    quitksort(1,9);
}
```
![某次运行中调用的活动树](./Picture/38.%E6%B4%BB%E5%8A%A8%E6%A0%91.png)

过程调用和返回通常由一个称为**控制栈**的运行时刻栈进行管理：
- 当一个过程是递归的时候，常常会有该过程的多个活动记录同时出现在栈中。  
- 每个活跃的活动都有一个位于控制栈中的活动记录
- 活动树的根的活动记录位于栈底
- 程序控制所在的活动记录位于栈顶
- 栈中全部活动记录的序列对应于在活动树中到达当前控制所在的活动结点的路径

根据所实现语言的不同，活动记录的内容也有所不同，如下列举了可能出现在一个活动记录中的各种类型的数据：
- 临时值，比如当表达式求值过程中产生的中间结果无法存放在寄存器中时， 就会生成这些临时值
- 对应于这个活动记录的过程的局部数据
- 保存的机器状态，其中包括对此过程的此次调用之前的机器状态信息。这些信息通常包括返回地址（程序计数器的值，被调用过程必须返回到该值所指位置）和一些寄存器中的内容（调用过程会使用这些内容，被调用过程必须在返回时恢复这些内容）
- 一个“访问链”。当被调用过程需要其他地方（比如另一个活动记录）的某个数据时，需要使用访问链进行定位。
- 一个**控制链**，指向调用者的活动记录
- 当被调用函数有返回值时，要有一个用于存放这个返回值的空间。
- 调用过程中使用的实参

|  |
|:--:|
|实参|
|返回值|
|控制链|
|访问链|
|保存的机器状态|
|局部数据|
|临时变量|
| |

## 设计活动记录的一些原则
![调用者和被调用者之间的职责划分](./Picture/39.%E8%B0%83%E7%94%A8%E8%80%85%E5%92%8C%E8%A2%AB%E8%B0%83%E7%94%A8%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%8C%E8%B4%A3%E5%88%92%E5%88%86.jpg)
- 在调用者和被调用者之间传递的值一般放在被调用者的活动记录开始位置，这样它们可以尽可能地靠近调用者的活动记录
- 固定长度的项被放置在中间位置（控制链、访问链、机器状态字）
- 在早期不知道大小的项被放置在活动记录的尾部（动态数组）
- 栈顶指针寄存器top_sp指向活动记录中**局部数据开始的位置**，以该地址作为基地址

# 4. 调用序列和返回序列
- 过程调用和过程返回都需要执行一些代码，来管理活动记录栈，保存或恢复机器状态等
    - 调用序列：实现过程调用的代码段，为一个活动记录在栈中分配空间，并在此记录的字段中填写信息
    - 返回序列：恢复机器状态，使得调用过程能够在调用结束之后继续执行
    - 一个调用代码序列中的代码通常被分割到调用过程（调用者）和被调用过程（被调用者）中。返回序列也是如此。

![调用序列](./Picture/40.%E8%B0%83%E7%94%A8%E5%BA%8F%E5%88%97.png)

![返回序列](./Picture/41.%E8%BF%94%E5%9B%9E%E5%BA%8F%E5%88%97.png)

![调用者和被调用者之间的任务划分](./Picture/42.%E8%B0%83%E7%94%A8%E8%80%85%E5%92%8C%E8%A2%AB%E8%B0%83%E7%94%A8%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%88%92%E5%88%86.png)

## 变长数据的存储分配
- 在现代程序设计语言中，在编译时刻不能确定大小的对象将被分配在堆区。但是，如果它们是过程的局部对象，也可以将它们分配在运行
时刻栈中。尽量将对象放置在栈区的原因：**可以避免对它们的空间进行垃圾回收，也就减少了相应的开销**
- 只有一个数据对象局部于某个过程，且当其过程结束时它变得不可访问，才可以使用栈为这个对象分配空间
# 5. 非局部数据的访问
- 一个过程除了可以使用过程自身定义的局部数据以外，还可以使用**过程外定义的非局部数据**
- 语言可分为两种类型
    - 支持过程嵌套声明的语言，可以在一个过程中声明另一个过程，比如Pascal
    - 不支持过程嵌套声明的语言，不可以在一个过程中声明另一个过程，比如C

### 对于不支持过程嵌套声明的语言，变量的存储分配和访问比较简单：
- 全局变量被分配在静态区，使用**静态确定的地址**访问它们
- 其他变量一定是栈顶活动的局部变量。可以通过运行时刻栈的top_sp指针访问它们

### 对于支持过程嵌套声明的数据访问
- **过程嵌套深度**
    - 不内嵌在任何其他过程中的过程，设其嵌套深度为1
    - 如果一个过程p在一个嵌套深度为i的过程中定义，则设其嵌套深度为i+1
- **变量的嵌套深度**
    - 将变量声明所在过程的嵌套深度作为该变量的嵌套深度

- 访问链
    - 静态作用域规则：只要过程b的声明嵌套在过程a的声明中，过程b就可以访问过程a中声明的对象
    - 可以在相互嵌套的过程的活动记录之间建立一种称为**访问链**的指针，使得内嵌的过程可以访问外层过程中声明的对象
        - 如果过程b在源代码中直接嵌套在过程a中，那么b的任何活动中的访问链都指向**最近的**a的活动

# 6. 符号表
编译器会为每个作用域（程序块）建立一个独立的符号表   
![符号表](./Picture/43.%E7%AC%A6%E5%8F%B7%E8%A1%A8.png)  
每个过程都有一个符号表，符号表会记录每个变量的名字、类型、相对地址，记录该作用域需要的字节数，以及该过程调用的其他过程的符号表的指针。    
实际上，这种**为每个过程或作用域建立的符号表**与编译时的**活动记录**是对应的。一个过程的**非局部名字的信息**可以通过扫描**外围过程的符号表**而得到。  
如上图所示，如果过程partition要访问a，在当前过程中没有找到a，那么就沿着红色箭头从quicksort的符号表中查找，继续沿着箭头在sort的符号表中查找到了a，那么就得到了a的信息。

## 总结：标识符的基本处理方法
- 当在某一层的**声明语句**中识别除一个标识符（id的**定义性出现**）时，以此标识符查相应于本层的符号表：
    - 如果查到，则报错并发出诊断信息：“id重复声明”
    - 邹泽，在符号表中加入新登记项，将标识符及有关信息填入
- 当在**可执行语句**部分扫视到标识符时（id的**应用性出现**）
    - 首先在该层符号表中查找该id，如果找不到，则到直接外层符号表中查，如此等等，一旦找到，则在表中取出有关信息做相应处理
    - 如果查遍所有外层符号表均未找到该id，则报错并发出诊断信息：“id未声明”

## 符号表的建立

